
from typing import List, Tuple, Optional, Union, Any, ContextManager, Callable, overload

import builtins
import math
import pickle

from .cuda import *

class dtype: ...
_dtype = dtype

class layout: ...

strided : layout = ...

class device:
    type: str = ...

    def __init__(self, device: Union[device, str, None]=None) -> None: ...

class Generator: ...

class Size(tuple): ...

class Storage: ...

class enable_grad():
    def __enter__(self) -> None: ...
    def __exit__(self, *args) -> None: ...
    def __call__(self, func : Callable) -> Callable: ...

class no_grad():
    def __enter__(self) -> None: ...
    def __exit__(self, *args) -> None: ...
    def __call__(self, func : Callable) -> Callable: ...

class set_grad_enabled():
    def __init__(self, mode: bool) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, *args) -> None: ...


class Tensor:
    dtype: _dtype = ...
    shape: Size = ...
    requires_grad: bool = ...
    grad: Optional['Tensor'] = ...
    device: device = ...

    def pin_memory(self) -> 'Tensor': ...

    def __abs__(self) -> 'Tensor': ...

    def __add__(self, other: Any) -> 'Tensor': ...

    def __and__(self, other: Any) -> 'Tensor': ...

    def __array__(self, dtype=None): ...

    def __array_wrap__(self, array): ...

    def __bool__(self) -> bool: ...

    def __deepcopy__(self, memo): ...

    def __dir__(self): ...

    def __div__(self, other: Any) -> 'Tensor': ...

    def __eq__(self, other: Any) -> 'Tensor': ...  # type: ignore

    def __float__(self) -> builtins.float: ...

    def __floordiv__(self, other): ...

    def __format__(self, format_spec): ...

    def __ge__(self, other: Any) -> 'Tensor': ...  # type: ignore

    def __getitem__(self, indices: Union[None, builtins.int, slice, 'Tensor', List, Tuple]) -> 'Tensor': ...

    def __gt__(self, other: Any) -> 'Tensor': ...  # type: ignore

    def __hash__(self): ...

    def __iadd__(self, other: Any) -> 'Tensor': ...

    def __iand__(self, other: Any) -> 'Tensor': ...

    def __idiv__(self, other: Any) -> 'Tensor': ...

    def __ilshift__(self, other: Any) -> 'Tensor': ...

    def __imul__(self, other: Any) -> 'Tensor': ...

    def __index__(self) -> builtins.int: ...

    def __int__(self) -> builtins.int: ...

    def __invert__(self) -> 'Tensor': ...

    def __ior__(self, other: Any) -> 'Tensor': ...

    def __ipow__(self, other): ...

    def __irshift__(self, other: Any) -> 'Tensor': ...

    def __isub__(self, other: Any) -> 'Tensor': ...

    def __iter__(self): ...

    def __itruediv__(self, other: Any) -> 'Tensor': ...

    def __ixor__(self, other: Any) -> 'Tensor': ...

    def __le__(self, other: Any) -> 'Tensor': ...  # type: ignore

    def __len__(self): ...

    def __long__(self) -> builtins.int: ...

    def __lshift__(self, other: Any) -> 'Tensor': ...

    def __lt__(self, other: Any) -> 'Tensor': ...  # type: ignore

    def __matmul__(self, other: Any) -> 'Tensor': ...

    def __mod__(self, other: Any) -> 'Tensor': ...

    def __mul__(self, other: Any) -> 'Tensor': ...

    def __ne__(self, other: Any) -> 'Tensor': ...  # type: ignore

    def __neg__(self) -> 'Tensor': ...

    def __nonzero__(self) -> bool: ...

    def __or__(self, other: Any) -> 'Tensor': ...

    def __pow__(self, other: Any) -> 'Tensor': ...

    def __radd__(self, other: Any) -> 'Tensor': ...

    def __rdiv__(self, other): ...

    def __reduce_ex__(self, proto): ...

    def __repr__(self): ...

    def __reversed__(self): ...

    def __rfloordiv__(self, other): ...

    def __rmul__(self, other: Any) -> 'Tensor': ...

    def __rpow__(self, other): ...

    def __rshift__(self, other: Any) -> 'Tensor': ...

    def __rsub__(self, other): ...

    def __rtruediv__(self, other): ...

    def __setitem__(self, indices: Union[None, builtins.int, slice, 'Tensor', List, Tuple], val: Union['Tensor', builtins.float, builtins.int]) -> None: ...

    def __setstate__(self, state): ...

    def __sub__(self, other: Any) -> 'Tensor': ...

    def __truediv__(self, other: Any) -> 'Tensor': ...

    def __xor__(self, other: Any) -> 'Tensor': ...

    def abs(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def abs_(self) -> 'Tensor': ...

    def acos(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def acos_(self) -> 'Tensor': ...

    @overload
    def add(self, other: 'Tensor', *, alpha: Union[builtins.float, builtins.int]=1, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def add(self, other: Union[builtins.float, builtins.int], alpha: Union[builtins.float, builtins.int]=1, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def add_(self, other: 'Tensor', *, alpha: Union[builtins.float, builtins.int]=1) -> 'Tensor': ...

    @overload
    def add_(self, other: Union[builtins.float, builtins.int], alpha: Union[builtins.float, builtins.int]=1) -> 'Tensor': ...

    def addbmm(self, batch1: 'Tensor', batch2: 'Tensor', *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1, out: Optional['Tensor']=None) -> 'Tensor': ...

    def addbmm_(self, batch1: 'Tensor', batch2: 'Tensor', *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1) -> 'Tensor': ...

    def addcdiv(self, tensor1: 'Tensor', tensor2: 'Tensor', *, value: Union[builtins.float, builtins.int]=1, out: Optional['Tensor']=None) -> 'Tensor': ...

    def addcdiv_(self, tensor1: 'Tensor', tensor2: 'Tensor', *, value: Union[builtins.float, builtins.int]=1) -> 'Tensor': ...

    def addcmul(self, tensor1: 'Tensor', tensor2: 'Tensor', *, value: Union[builtins.float, builtins.int]=1, out: Optional['Tensor']=None) -> 'Tensor': ...

    def addcmul_(self, tensor1: 'Tensor', tensor2: 'Tensor', *, value: Union[builtins.float, builtins.int]=1) -> 'Tensor': ...

    def addmm(self, mat1: 'Tensor', mat2: 'Tensor', *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1, out: Optional['Tensor']=None) -> 'Tensor': ...

    def addmm_(self, mat1: 'Tensor', mat2: 'Tensor', *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1) -> 'Tensor': ...

    def addmv(self, mat: 'Tensor', vec: 'Tensor', *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1, out: Optional['Tensor']=None) -> 'Tensor': ...

    def addmv_(self, mat: 'Tensor', vec: 'Tensor', *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1) -> 'Tensor': ...

    def addr(self, vec1: 'Tensor', vec2: 'Tensor', *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1, out: Optional['Tensor']=None) -> 'Tensor': ...

    def addr_(self, vec1: 'Tensor', vec2: 'Tensor', *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1) -> 'Tensor': ...

    @overload
    def all(self, *, out: Optional['Tensor']=None) -> Union[builtins.float, builtins.int]: ...

    @overload
    def all(self, dim: builtins.int, keepdim: bool=False, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def allclose(self, other: 'Tensor', rtol: builtins.float=1e-05, atol: builtins.float=1e-08, equal_nan: bool=False) -> bool: ...

    @overload
    def any(self) -> 'Tensor': ...

    @overload
    def any(self, dim: builtins.int, keepdim: bool=False, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def apply_(self, callable: Callable) -> 'Tensor': ...

    def argmax(self, dim=None, keepdim=False): ...

    def argmin(self, dim=None, keepdim=False): ...

    def argsort(self, dim=None, descending=False): ...

    def asin(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def asin_(self) -> 'Tensor': ...

    def atan(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def atan2(self, other: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def atan2_(self, other: 'Tensor') -> 'Tensor': ...

    def atan_(self) -> 'Tensor': ...

    def backward(self, gradient=None, retain_graph=None, create_graph=False): ...

    def baddbmm(self, batch1: 'Tensor', batch2: 'Tensor', *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1, out: Optional['Tensor']=None) -> 'Tensor': ...

    def baddbmm_(self, batch1: 'Tensor', batch2: 'Tensor', *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1) -> 'Tensor': ...

    @overload
    def bernoulli(self, *, generator: Generator=None, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def bernoulli(self, p: builtins.float, *, generator: Generator=None, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def bernoulli_(self, p: 'Tensor', *, generator: Generator=None) -> 'Tensor': ...

    @overload
    def bernoulli_(self, p: builtins.float=0.5, *, generator: Generator=None) -> 'Tensor': ...

    def bincount(self, weights: Optional['Tensor']=None, minlength: builtins.int=0) -> 'Tensor': ...

    def bmm(self, mat2: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def btrifact(self, info=None, pivot=True): ...

    def btrifact_with_info(self, *, pivot: bool=True, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor', 'Tensor']: ...

    def btrisolve(self, LU_data: 'Tensor', LU_pivots: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def byte(self) -> 'Tensor': ...

    def cauchy_(self, median: builtins.float=0, sigma: builtins.float=1, *, generator: Generator=None) -> 'Tensor': ...

    def ceil(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def ceil_(self) -> 'Tensor': ...

    def char(self) -> 'Tensor': ...

    def chunk(self, chunks: builtins.int, dim: builtins.int=0) -> Union[Tuple['Tensor', ...],List['Tensor']]: ...

    def clamp(self, min: builtins.float=-math.inf, max: builtins.float =math.inf, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def clamp_(self, min: builtins.float=-math.inf, max: builtins.float =math.inf) -> 'Tensor': ...

    def clone(self) -> 'Tensor': ...

    def contiguous(self) -> 'Tensor': ...

    def copy_(self, src: 'Tensor', non_blocking: bool=False) -> 'Tensor': ...

    def cos(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def cos_(self) -> 'Tensor': ...

    def cosh(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def cosh_(self) -> 'Tensor': ...

    def cpu(self) -> 'Tensor': ...

    def cross(self, other: 'Tensor', dim: builtins.int=-1, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def cuda(self, device: Union[device, str, None]=None, non_blocking: bool=False) -> 'Tensor': ...

    @overload
    def cumprod(self, dim: builtins.int, *, dtype: _dtype, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def cumprod(self, dim: builtins.int, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def cumsum(self, dim: builtins.int, *, dtype: _dtype, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def cumsum(self, dim: builtins.int, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def data_ptr(self) -> builtins.int: ...

    def det(self) -> 'Tensor': ...

    def detach(self) -> 'Tensor': ...

    def detach_(self) -> 'Tensor': ...

    def diag(self, diagonal: builtins.int=0, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def diagflat(self, offset: builtins.int=0) -> 'Tensor': ...

    def diagonal(self, offset: builtins.int=0, dim1: builtins.int=0, dim2: builtins.int=1) -> 'Tensor': ...

    def digamma(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def digamma_(self) -> 'Tensor': ...

    def dim(self) -> builtins.int: ...

    def dist(self, other: 'Tensor', p: Union[builtins.float, builtins.int]=2) -> Union[builtins.float, builtins.int]: ...

    @overload
    def div(input, other: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def div(input, other: Union[builtins.float, builtins.int], *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def div_(input, other: 'Tensor') -> 'Tensor': ...

    @overload
    def div_(input, other: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    def dot(self, tensor: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def double(self) -> 'Tensor': ...

    def eig(self, eigenvectors: bool=False, *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    def element_size(self) -> builtins.int: ...

    @overload
    def eq(input, other: Union[builtins.float, builtins.int], *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def eq(input, other: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def eq_(input, other: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    @overload
    def eq_(self, other: 'Tensor') -> 'Tensor': ...

    def equal(self, other: 'Tensor') -> bool: ...

    def erf(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def erf_(self) -> 'Tensor': ...

    def erfc(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def erfc_(self) -> 'Tensor': ...

    def erfinv(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def erfinv_(self) -> 'Tensor': ...

    def exp(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def exp_(self) -> 'Tensor': ...

    @overload
    def expand(self, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], *, implicit: bool=False) -> 'Tensor': ...

    @overload
    def expand(self, *size: builtins.int, implicit: bool=False) -> 'Tensor': ...

    def expand_as(self, other: 'Tensor') -> 'Tensor': ...

    def expm1(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def expm1_(self) -> 'Tensor': ...

    def exponential_(self, lambd: builtins.float=1, *, generator: Generator=None) -> 'Tensor': ...

    def fft(self, signal_ndim: builtins.int, normalized: bool=False) -> 'Tensor': ...

    @overload
    def fill_(self, value: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    @overload
    def fill_(self, value: 'Tensor') -> 'Tensor': ...

    def flatten(self, start_dim: builtins.int=0, end_dim: builtins.int=-1) -> 'Tensor': ...

    @overload
    def flip(self, dims: Union[Tuple[builtins.int, ...], List[builtins.int], Size]) -> 'Tensor': ...

    @overload
    def flip(self, *dims: builtins.int) -> 'Tensor': ...

    def float(self) -> 'Tensor': ...

    def floor(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def floor_(self) -> 'Tensor': ...

    @overload
    def fmod(self, other: Union[builtins.float, builtins.int], *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def fmod(self, other: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def fmod_(self, other: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    @overload
    def fmod_(self, other: 'Tensor') -> 'Tensor': ...

    def frac(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def frac_(self) -> 'Tensor': ...

    def gather(self, dim: builtins.int, index: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def ge(self, other: Union[builtins.float, builtins.int], *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def ge(self, other: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def ge_(self, other: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    @overload
    def ge_(self, other: 'Tensor') -> 'Tensor': ...

    def gels(self, A: 'Tensor', *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    def geometric_(self, p: builtins.float, *, generator: Generator=None) -> 'Tensor': ...

    def geqrf(self, *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    def ger(self, vec2: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def gesv(self, A: 'Tensor', *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    def get_device(self) -> builtins.int: ...

    @overload
    def gt(self, other: Union[builtins.float, builtins.int], *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def gt(self, other: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def gt_(self, other: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    @overload
    def gt_(self, other: 'Tensor') -> 'Tensor': ...

    def half(self) -> 'Tensor': ...

    def hardshrink(self, lambd: Union[builtins.float, builtins.int]=0.5) -> 'Tensor': ...

    def histc(self, bins: builtins.int=100, min: Union[builtins.float, builtins.int]=0, max: Union[builtins.float, builtins.int]=0, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def ifft(self, signal_ndim: builtins.int, normalized: bool=False) -> 'Tensor': ...

    def index_add(self, dim, index, tensor): ...

    def index_add_(self, dim: builtins.int, index: 'Tensor', source: 'Tensor') -> 'Tensor': ...

    def index_copy(self, dim, index, tensor): ...

    def index_copy_(self, dim: builtins.int, index: 'Tensor', source: 'Tensor') -> 'Tensor': ...

    def index_fill(self, dim, index, value): ...

    @overload
    def index_fill_(self, dim: builtins.int, index: 'Tensor', value: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    @overload
    def index_fill_(self, dim: builtins.int, index: 'Tensor', value: 'Tensor') -> 'Tensor': ...

    def index_put_(self, indices: Union[Tuple['Tensor', ...],List['Tensor']], values: 'Tensor') -> 'Tensor': ...

    def index_select(self, dim: builtins.int, index: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def int(self) -> 'Tensor': ...

    def inverse(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def irfft(self, signal_ndim: builtins.int, normalized: bool=False, onesided: bool=True, signal_sizes: Union[Tuple[builtins.int, ...], List[builtins.int], Size]=()) -> 'Tensor': ...

    def is_contiguous(self) -> bool: ...

    def is_pinned(self): ...

    def is_set_to(self, tensor: 'Tensor') -> bool: ...

    def is_shared(self): ...

    def item(self) -> Union[builtins.float, builtins.int]: ...

    def kthvalue(self, k: builtins.int, dim: builtins.int=-1, keepdim: bool=False, *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    @overload
    def le(self, other: Union[builtins.float, builtins.int], *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def le(self, other: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def le_(self, other: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    @overload
    def le_(self, other: 'Tensor') -> 'Tensor': ...

    def lerp(self, end: 'Tensor', weight: Union[builtins.float, builtins.int], *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def lerp_(self, end: 'Tensor', weight: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    def log(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def log10(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def log10_(self) -> 'Tensor': ...

    def log1p(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def log1p_(self) -> 'Tensor': ...

    def log2(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def log2_(self) -> 'Tensor': ...

    def log_(self) -> 'Tensor': ...

    def log_normal_(self, mean: builtins.float=1, std: builtins.float=2, *, generator: Generator=None) -> 'Tensor': ...

    def logdet(self) -> 'Tensor': ...

    def logsumexp(self, dim: builtins.int, keepdim: bool=False, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def long(self) -> 'Tensor': ...

    @overload
    def lt(self, other: Union[builtins.float, builtins.int], *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def lt(self, other: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def lt_(self, other: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    @overload
    def lt_(self, other: 'Tensor') -> 'Tensor': ...

    def map_(tensor: 'Tensor', callable: Callable) -> 'Tensor': ...

    @overload
    def masked_fill_(self, mask: 'Tensor', value: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    @overload
    def masked_fill_(self, mask: 'Tensor', value: 'Tensor') -> 'Tensor': ...

    def masked_scatter(self, mask, tensor): ...

    def masked_scatter_(self, mask: 'Tensor', source: 'Tensor') -> 'Tensor': ...

    def masked_select(self, mask: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def matmul(self, other: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def matrix_power(self, n: builtins.int) -> 'Tensor': ...

    @overload
    def max(self, other: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def max(self, *, out: Optional['Tensor']=None) -> Union[builtins.float, builtins.int]: ...

    @overload
    def max(self, dim: builtins.int, keepdim: bool=False, *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    @overload
    def mean(self, *, dtype: _dtype, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def mean(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def mean(self, dim: builtins.int, keepdim: bool, *, dtype: _dtype, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def mean(self, dim: builtins.int, keepdim: bool=False, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def mean(self, dim: builtins.int, *, dtype: _dtype, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def median(self, *, out: Optional['Tensor']=None) -> Union[builtins.float, builtins.int]: ...

    @overload
    def median(self, dim: builtins.int, keepdim: bool=False, *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    @overload
    def min(self, other: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def min(self, *, out: Optional['Tensor']=None) -> Union[builtins.float, builtins.int]: ...

    @overload
    def min(self, dim: builtins.int, keepdim: bool=False, *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    def mm(self, mat2: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def mode(self, dim: builtins.int=-1, keepdim: bool=False, *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    @overload
    def mul(self, other: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def mul(self, other: Union[builtins.float, builtins.int], *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def mul_(self, other: 'Tensor') -> 'Tensor': ...

    @overload
    def mul_(self, other: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    def multinomial(self, num_samples: builtins.int, replacement: bool=False, *, generator: Generator=None, out: Optional['Tensor']=None) -> 'Tensor': ...

    def mv(self, vec: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def mvlgamma(self, p: builtins.int) -> 'Tensor': ...

    def mvlgamma_(self, p: builtins.int) -> 'Tensor': ...

    def narrow(self, dim: builtins.int, start: builtins.int, length: builtins.int) -> 'Tensor': ...

    def narrow_copy(self, dim: builtins.int, start: builtins.int, length: builtins.int) -> 'Tensor': ...

    def ndimension(self) -> builtins.int: ...

    @overload
    def ne(self, other: Union[builtins.float, builtins.int], *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def ne(self, other: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def ne_(self, other: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    @overload
    def ne_(self, other: 'Tensor') -> 'Tensor': ...

    def neg(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def neg_(self) -> 'Tensor': ...

    def nelement(self) -> builtins.int: ...

    def new_empty(self, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], dtype: Optional[_dtype]=None, device: Union[device, str, None]=None, requires_grad: bool=False) -> 'Tensor': ...

    def new_full(self, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], value: Union[builtins.float, builtins.int], dtype: Optional[_dtype]=None, device: Union[device, str, None]=None, requires_grad: bool=False) -> 'Tensor': ...

    def new_ones(self, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], dtype: Optional[_dtype]=None, device: Union[device, str, None]=None, requires_grad: bool=False) -> 'Tensor': ...

    def new_tensor(self, data: Any, dtype: Optional[_dtype]=None, device: Union[device, str, None]=None, requires_grad: bool=False) -> 'Tensor': ...

    def new_zeros(self, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], dtype: Optional[_dtype]=None, device: Union[device, str, None]=None, requires_grad: bool=False) -> 'Tensor': ...

    def nonzero(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def norm(self, p='fro', dim=None, keepdim=False): ...

    def normal_(self, mean: builtins.float=0, std: builtins.float=1, *, generator: Generator=None) -> 'Tensor': ...

    def numel(self) -> builtins.int: ...

    def numpy(self) -> Any: ...

    def orgqr(self, input2: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def ormqr(self, input2: 'Tensor', input3: 'Tensor', left: bool=True, transpose: bool=False, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def permute(self, dims: Union[Tuple[builtins.int, ...], List[builtins.int], Size]) -> 'Tensor': ...

    @overload
    def permute(self, *dims: builtins.int) -> 'Tensor': ...

    def pinverse(self, rcond: builtins.float=1e-15) -> 'Tensor': ...

    def potrf(self, upper: bool=True, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def potri(self, upper: bool=True, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def potrs(self, input2: 'Tensor', upper: bool=True, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def pow(self, exponent: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def pow(self, exponent: Union[builtins.float, builtins.int], *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def pow_(self, exponent: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    @overload
    def pow_(self, exponent: 'Tensor') -> 'Tensor': ...

    @overload
    def prod(self, *, dtype: _dtype, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def prod(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def prod(self, dim: builtins.int, keepdim: bool, *, dtype: _dtype, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def prod(self, dim: builtins.int, keepdim: bool=False, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def prod(self, dim: builtins.int, *, dtype: _dtype, out: Optional['Tensor']=None) -> 'Tensor': ...

    def pstrf(self, upper: bool=True, tol: Union[builtins.float, builtins.int]=-1, *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    def put_(self, index: 'Tensor', source: 'Tensor', accumulate: bool=False) -> 'Tensor': ...

    def qr(self, *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    @overload
    def random_(self, from_: builtins.int, to: builtins.int, *, generator: Generator=None) -> 'Tensor': ...

    @overload
    def random_(self, to: builtins.int, *, generator: Generator=None) -> 'Tensor': ...

    @overload
    def random_(self, *, generator: Generator=None) -> 'Tensor': ...

    def reciprocal(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def reciprocal_(self) -> 'Tensor': ...

    def register_hook(self, hook): ...

    @overload
    def remainder(self, other: Union[builtins.float, builtins.int], *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def remainder(self, other: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def remainder_(self, other: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    @overload
    def remainder_(self, other: 'Tensor') -> 'Tensor': ...

    def renorm(self, p: Union[builtins.float, builtins.int], dim: builtins.int, maxnorm: Union[builtins.float, builtins.int], *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def renorm_(self, p: Union[builtins.float, builtins.int], dim: builtins.int, maxnorm: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    @overload
    def repeat(self, repeats: Union[Tuple[builtins.int, ...], List[builtins.int], Size]) -> 'Tensor': ...

    @overload
    def repeat(self, *repeats: builtins.int) -> 'Tensor': ...

    def requires_grad_(self, mode: bool=True) -> 'Tensor': ...

    @overload
    def reshape(self, shape: Union[Tuple[builtins.int, ...], List[builtins.int], Size]) -> 'Tensor': ...

    @overload
    def reshape(self, *shape: builtins.int) -> 'Tensor': ...

    def reshape_as(self, other: 'Tensor') -> 'Tensor': ...

    @overload
    def resize_(self, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size]) -> 'Tensor': ...

    @overload
    def resize_(self, *size: builtins.int) -> 'Tensor': ...

    def resize_as_(self, the_template: 'Tensor') -> 'Tensor': ...

    def retain_grad(self): ...

    def rfft(self, signal_ndim: builtins.int, normalized: bool=False, onesided: bool=True) -> 'Tensor': ...

    def rot90(self, k: builtins.int=1, dims: Union[Tuple[builtins.int, ...], List[builtins.int], Size]=(0,1)) -> 'Tensor': ...

    def round(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def round_(self) -> 'Tensor': ...

    def rsqrt(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def rsqrt_(self) -> 'Tensor': ...

    def scatter(self, dim, index, source): ...

    @overload
    def scatter_(self, dim: builtins.int, index: 'Tensor', src: 'Tensor') -> 'Tensor': ...

    @overload
    def scatter_(self, dim: builtins.int, index: 'Tensor', value: Union[builtins.float, builtins.int]) -> 'Tensor': ...

    def scatter_add(self, dim, index, source): ...

    def scatter_add_(self, dim: builtins.int, index: 'Tensor', src: 'Tensor') -> 'Tensor': ...

    def select(self, dim: builtins.int, index: builtins.int) -> 'Tensor': ...

    @overload
    def set_(self, source: Storage) -> 'Tensor': ...

    @overload
    def set_(self, source: Storage, storage_offset: builtins.int, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], stride: Union[Tuple[builtins.int, ...], List[builtins.int], Size]=()) -> 'Tensor': ...

    @overload
    def set_(self, source: 'Tensor') -> 'Tensor': ...

    @overload
    def set_(self) -> 'Tensor': ...

    def share_memory_(self): ...

    def short(self) -> 'Tensor': ...

    def sigmoid(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def sigmoid_(self) -> 'Tensor': ...

    def sign(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def sign_(self) -> 'Tensor': ...

    def sin(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def sin_(self) -> 'Tensor': ...

    def sinh(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def sinh_(self) -> 'Tensor': ...

    @overload
    def size(self) -> Size: ...

    @overload
    def size(self, dim: builtins.int) -> builtins.int: ...

    def slogdet(self) -> Tuple['Tensor', 'Tensor']: ...

    def sort(self, dim: builtins.int=-1, descending: bool=False, *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    def split(self, split_size, dim=0): ...

    def sqrt(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def sqrt_(self) -> 'Tensor': ...

    @overload
    def squeeze(self) -> 'Tensor': ...

    @overload
    def squeeze(self, dim: builtins.int) -> 'Tensor': ...

    @overload
    def squeeze_(self) -> 'Tensor': ...

    @overload
    def squeeze_(self, dim: builtins.int) -> 'Tensor': ...

    @overload
    def std(self, unbiased: bool=True, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def std(self, dim: builtins.int, unbiased: bool=True, keepdim: bool=False, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def stft(self, n_fft, hop_length=None, win_length=None, window=None, center=True, pad_mode='reflect', normalized=False, onesided=True): ...

    def storage(self) -> Storage: ...

    def storage_offset(self) -> builtins.int: ...

    @overload
    def stride(self) -> Tuple[builtins.int]: ...

    @overload
    def stride(self, dim: builtins.int) -> builtins.int: ...

    @overload
    def sub(self, other: 'Tensor', *, alpha: Union[builtins.float, builtins.int]=1, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def sub(self, other: Union[builtins.float, builtins.int], alpha: Union[builtins.float, builtins.int]=1, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def sub_(self, other: 'Tensor', *, alpha: Union[builtins.float, builtins.int]=1) -> 'Tensor': ...

    @overload
    def sub_(self, other: Union[builtins.float, builtins.int], alpha: Union[builtins.float, builtins.int]=1) -> 'Tensor': ...

    @overload
    def sum(self, *, dtype: _dtype, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def sum(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def sum(self, dim: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size], keepdim: bool, *, dtype: _dtype, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def sum(self, dim: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size], keepdim: bool=False, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def sum(self, dim: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size], *, dtype: _dtype, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def sum(self, *dim: builtins.int, dtype: _dtype, out: Optional['Tensor']=None) -> 'Tensor': ...

    def svd(self, some: bool=True, compute_uv: bool=True, *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor', 'Tensor']: ...

    def symeig(self, eigenvectors: bool=False, upper: bool=True, *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    def t(self) -> 'Tensor': ...

    def t_(self) -> 'Tensor': ...

    def take(self, index: 'Tensor', *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def tan_(self) -> 'Tensor': ...

    def tanh(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def tanh_(self) -> 'Tensor': ...

    @overload
    def to(self, device: Union[device, str, None], dtype: _dtype, non_blocking: bool=False, copy: bool=False) -> 'Tensor': ...

    @overload
    def to(self, dtype: _dtype, non_blocking: bool=False, copy: bool=False) -> 'Tensor': ...

    @overload
    def to(self, device: Union[device, str, None], non_blocking: bool=False, copy: bool=False) -> 'Tensor': ...

    @overload
    def to(self, other: 'Tensor', non_blocking: bool=False, copy: bool=False) -> 'Tensor': ...

    def tolist(self) -> List: ...

    def topk(self, k: builtins.int, dim: builtins.int=-1, largest: bool=True, sorted: bool=True, *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    def trace(self) -> Union[builtins.float, builtins.int]: ...

    def transpose(self, dim0: builtins.int, dim1: builtins.int) -> 'Tensor': ...

    def transpose_(self, dim0: builtins.int, dim1: builtins.int) -> 'Tensor': ...

    def tril(self, diagonal: builtins.int=0, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def tril_(self, diagonal: builtins.int=0) -> 'Tensor': ...

    def triu(self, diagonal: builtins.int=0, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def triu_(self, diagonal: builtins.int=0) -> 'Tensor': ...

    def trtrs(self, A: 'Tensor', upper: bool=True, transpose: bool=False, unitriangular: bool=False, *, out: Optional['Tensor']=None) -> Tuple['Tensor', 'Tensor']: ...

    def trunc(self, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    def trunc_(self) -> 'Tensor': ...

    def type(self, dtype: Union[None, str, _dtype]=None, non_blocking: bool=False) -> Union[str, 'Tensor']: ...

    def type_as(self, other: 'Tensor') -> 'Tensor': ...

    def unbind(self, dim: builtins.int=0) -> Union[Tuple['Tensor', ...],List['Tensor']]: ...

    def unfold(self, dimension: builtins.int, size: builtins.int, step: builtins.int) -> 'Tensor': ...

    def uniform_(self, from_: builtins.float=0, to: builtins.float=1, *, generator: Generator=None) -> 'Tensor': ...

    def unique(self, sorted=False, return_inverse=False, dim=None): ...

    def unsqueeze(self, dim: builtins.int) -> 'Tensor': ...

    def unsqueeze_(self, dim: builtins.int) -> 'Tensor': ...

    @overload
    def var(self, unbiased: bool=True, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def var(self, dim: builtins.int, unbiased: bool=True, keepdim: bool=False, *, out: Optional['Tensor']=None) -> 'Tensor': ...

    @overload
    def view(self, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size]) -> 'Tensor': ...

    @overload
    def view(self, *size: builtins.int) -> 'Tensor': ...

    def view_as(self, other: 'Tensor') -> 'Tensor': ...

    def where(self, condition: 'Tensor', other: 'Tensor') -> 'Tensor': ...

    def zero_(self) -> 'Tensor': ...


def abs(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def acos(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def adaptive_avg_pool1d(input: Tensor, output_size: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]) -> Tensor: ...

@overload
def add(input: Tensor, other: Tensor, *, alpha: Union[builtins.float, builtins.int]=1, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def add(input: Tensor, other: Union[builtins.float, builtins.int], alpha: Union[builtins.float, builtins.int]=1, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def add(input: Tensor, alpha: Union[builtins.float, builtins.int], other: Tensor) -> Tensor: ...

@overload
def add(input: Tensor, alpha: Union[builtins.float, builtins.int], other: Tensor, *, out: Tensor) -> Tensor: ...

@overload
def addbmm(input: Tensor, batch1: Tensor, batch2: Tensor, *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def addbmm(beta: Union[builtins.float, builtins.int], input: Tensor, alpha: Union[builtins.float, builtins.int], batch1: Tensor, batch2: Tensor) -> Tensor: ...

@overload
def addbmm(beta: Union[builtins.float, builtins.int], input: Tensor, alpha: Union[builtins.float, builtins.int], batch1: Tensor, batch2: Tensor, *, out: Tensor) -> Tensor: ...

@overload
def addbmm(beta: Union[builtins.float, builtins.int], input: Tensor, batch1: Tensor, batch2: Tensor) -> Tensor: ...

@overload
def addbmm(beta: Union[builtins.float, builtins.int], input: Tensor, batch1: Tensor, batch2: Tensor, *, out: Tensor) -> Tensor: ...

@overload
def addcdiv(input: Tensor, tensor1: Tensor, tensor2: Tensor, *, value: Union[builtins.float, builtins.int]=1, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def addcdiv(input: Tensor, value: Union[builtins.float, builtins.int], tensor1: Tensor, tensor2: Tensor) -> Tensor: ...

@overload
def addcdiv(input: Tensor, value: Union[builtins.float, builtins.int], tensor1: Tensor, tensor2: Tensor, *, out: Tensor) -> Tensor: ...

@overload
def addcmul(input: Tensor, tensor1: Tensor, tensor2: Tensor, *, value: Union[builtins.float, builtins.int]=1, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def addcmul(input: Tensor, value: Union[builtins.float, builtins.int], tensor1: Tensor, tensor2: Tensor) -> Tensor: ...

@overload
def addcmul(input: Tensor, value: Union[builtins.float, builtins.int], tensor1: Tensor, tensor2: Tensor, *, out: Tensor) -> Tensor: ...

@overload
def addmm(input: Tensor, mat1: Tensor, mat2: Tensor, *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def addmm(beta: Union[builtins.float, builtins.int], input: Tensor, alpha: Union[builtins.float, builtins.int], mat1: Tensor, mat2: Tensor) -> Tensor: ...

@overload
def addmm(beta: Union[builtins.float, builtins.int], input: Tensor, alpha: Union[builtins.float, builtins.int], mat1: Tensor, mat2: Tensor, *, out: Tensor) -> Tensor: ...

@overload
def addmm(beta: Union[builtins.float, builtins.int], input: Tensor, mat1: Tensor, mat2: Tensor) -> Tensor: ...

@overload
def addmm(beta: Union[builtins.float, builtins.int], input: Tensor, mat1: Tensor, mat2: Tensor, *, out: Tensor) -> Tensor: ...

@overload
def addmv(input: Tensor, mat: Tensor, vec: Tensor, *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def addmv(beta: Union[builtins.float, builtins.int], input: Tensor, alpha: Union[builtins.float, builtins.int], mat: Tensor, vec: Tensor) -> Tensor: ...

@overload
def addmv(beta: Union[builtins.float, builtins.int], input: Tensor, alpha: Union[builtins.float, builtins.int], mat: Tensor, vec: Tensor, *, out: Tensor) -> Tensor: ...

@overload
def addmv(beta: Union[builtins.float, builtins.int], input: Tensor, mat: Tensor, vec: Tensor) -> Tensor: ...

@overload
def addmv(beta: Union[builtins.float, builtins.int], input: Tensor, mat: Tensor, vec: Tensor, *, out: Tensor) -> Tensor: ...

@overload
def addr(input: Tensor, vec1: Tensor, vec2: Tensor, *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def addr(beta: Union[builtins.float, builtins.int], input: Tensor, alpha: Union[builtins.float, builtins.int], vec1: Tensor, vec2: Tensor) -> Tensor: ...

@overload
def addr(beta: Union[builtins.float, builtins.int], input: Tensor, alpha: Union[builtins.float, builtins.int], vec1: Tensor, vec2: Tensor, *, out: Tensor) -> Tensor: ...

@overload
def addr(beta: Union[builtins.float, builtins.int], input: Tensor, vec1: Tensor, vec2: Tensor) -> Tensor: ...

@overload
def addr(beta: Union[builtins.float, builtins.int], input: Tensor, vec1: Tensor, vec2: Tensor, *, out: Tensor) -> Tensor: ...

def allclose(input: Tensor, other: Tensor, rtol: builtins.float=1e-05, atol: builtins.float=1e-08, equal_nan: bool=False) -> bool: ...

@overload
def any(input: 'Tensor', dim: builtins.int, keepdim: bool=False, *, out: Optional['Tensor']=None) -> 'Tensor': ...

@overload
def arange(start: Union[builtins.float, builtins.int], end: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def arange(start: Union[builtins.float, builtins.int], end: Union[builtins.float, builtins.int], step: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def arange(end: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

def argmax(input, dim=None, keepdim=False): ...

def argmin(input, dim=None, keepdim=False): ...

def argsort(input, dim=None, descending=False): ...

def as_tensor(data: Any, dtype: _dtype=None, device: Union[device, str, None]=None) -> Tensor: ...

def asin(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def atan(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def atan2(input: Tensor, other: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def avg_pool1d(input: Tensor, kernel_size: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size], stride: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=(), padding: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=0, ceil_mode: bool=False, count_include_pad: bool=True) -> Tensor: ...

@overload
def baddbmm(input: Tensor, batch1: Tensor, batch2: Tensor, *, beta: Union[builtins.float, builtins.int]=1, alpha: Union[builtins.float, builtins.int]=1, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def baddbmm(beta: Union[builtins.float, builtins.int], input: Tensor, alpha: Union[builtins.float, builtins.int], batch1: Tensor, batch2: Tensor) -> Tensor: ...

@overload
def baddbmm(beta: Union[builtins.float, builtins.int], input: Tensor, alpha: Union[builtins.float, builtins.int], batch1: Tensor, batch2: Tensor, *, out: Tensor) -> Tensor: ...

@overload
def baddbmm(beta: Union[builtins.float, builtins.int], input: Tensor, batch1: Tensor, batch2: Tensor) -> Tensor: ...

@overload
def baddbmm(beta: Union[builtins.float, builtins.int], input: Tensor, batch1: Tensor, batch2: Tensor, *, out: Tensor) -> Tensor: ...

@overload
def bartlett_window(window_length: builtins.int, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def bartlett_window(window_length: builtins.int, periodic: bool, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def bernoulli(input: Tensor, *, generator: Generator=None, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def bernoulli(input: Tensor, p: builtins.float, *, generator: Generator=None, out: Optional[Tensor]=None) -> Tensor: ...

def bincount(input: Tensor, weights: Optional[Tensor]=None, minlength: builtins.int=0) -> Tensor: ...

@overload
def blackman_window(window_length: builtins.int, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def blackman_window(window_length: builtins.int, periodic: bool, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

def bmm(input: Tensor, mat2: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def broadcast_tensors(*tensors:Tensor) -> List[Tensor]: ...

def btrifact(A:Tensor, info:Union[Tensor, None]=None, pivot:bool=True) -> Tuple[Tensor, Tensor]: ...

def btrifact_with_info(input: Tensor, *, pivot: bool=True, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor, Tensor]: ...

def btrisolve(input: Tensor, LU_data: Tensor, LU_pivots: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def btriunpack(LU_data:Tensor, LU_pivots:Tensor, unpack_data:bool=True, unpack_pivots:bool=True) -> Tuple[Tensor, Tensor, Tensor]: ...

def cat(tensors: Union[Tuple[Tensor, ...],List[Tensor]], dim: builtins.int=0, *, out: Optional[Tensor]=None) -> Tensor: ...

def ceil(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def celu_(input: Tensor, alpha: Union[builtins.float, builtins.int]=1.0) -> Tensor: ...

def chain_matmul(*matrices): ...

def chunk(input: Tensor, chunks: builtins.int, dim: builtins.int=0) -> Union[Tuple[Tensor, ...],List[Tensor]]: ...

def clamp(input, min: builtins.float=-math.inf, max: builtins.float=math.inf, *, out: Optional[Tensor]=None) -> Tensor: ...

def compiled_with_cxx11_abi(): ...

def conv1d(input: Tensor, weight: Tensor, bias: Tensor=None, stride: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=1, padding: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=0, dilation: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=1, groups: builtins.int=1) -> Tensor: ...

def conv2d(input: Tensor, weight: Tensor, bias: Tensor=None, stride: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=1, padding: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=0, dilation: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=1, groups: builtins.int=1) -> Tensor: ...

def conv3d(input: Tensor, weight: Tensor, bias: Tensor=None, stride: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=1, padding: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=0, dilation: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=1, groups: builtins.int=1) -> Tensor: ...

def conv_tbc(input: Tensor, weight: Tensor, bias: Tensor, pad: builtins.int=0) -> Tensor: ...

def conv_transpose1d(input: Tensor, weight: Tensor, bias: Tensor=None, stride: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=1, padding: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=0, output_padding: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=0, groups: builtins.int=1, dilation: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=1) -> Tensor: ...

def conv_transpose2d(input: Tensor, weight: Tensor, bias: Tensor=None, stride: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=1, padding: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=0, output_padding: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=0, groups: builtins.int=1, dilation: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=1) -> Tensor: ...

def conv_transpose3d(input: Tensor, weight: Tensor, bias: Tensor=None, stride: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=1, padding: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=0, output_padding: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=0, groups: builtins.int=1, dilation: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size]=1) -> Tensor: ...

def cos(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def cosh(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def cross(input: Tensor, other: Tensor, dim: builtins.int=-1, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def cumprod(input: Tensor, dim: builtins.int, *, dtype: _dtype, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def cumprod(input: Tensor, dim: builtins.int, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def cumsum(input: Tensor, dim: builtins.int, *, dtype: _dtype, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def cumsum(input: Tensor, dim: builtins.int, *, out: Optional[Tensor]=None) -> Tensor: ...

def det(input: Tensor) -> Tensor: ...

def diag(input: Tensor, diagonal: builtins.int=0, *, out: Optional[Tensor]=None) -> Tensor: ...

def diagflat(input: Tensor, offset: builtins.int=0) -> Tensor: ...

def diagonal(input: Tensor, offset: builtins.int=0, dim1: builtins.int=0, dim2: builtins.int=1) -> Tensor: ...

def digamma(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def dist(input: Tensor, other: Tensor, p: Union[builtins.float, builtins.int]=2) -> Union[builtins.float, builtins.int]: ...

@overload
def div(input: Tensor, other: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def div(input: Tensor, other: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None) -> Tensor: ...

def dot(input: Tensor, tensor: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def eig(input: Tensor, eigenvectors: bool=False, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

def einsum(equation:str, *operands:Tensor) -> Tensor: ...

@overload
def empty(size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def empty(*size: builtins.int, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def empty_like(input: Tensor) -> Tensor: ...

@overload
def empty_like(input: Tensor, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def eq(input: Tensor, other: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def eq(input: Tensor, other: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def equal(input: Tensor, other: Tensor) -> bool: ...

def erf(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def erfc(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def erfinv(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def exp(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def expm1(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def eye(n: builtins.int, *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def eye(n: builtins.int, m: builtins.int, *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

def fft(input: Tensor, signal_ndim: builtins.int, normalized: bool=False) -> Tensor: ...

def flatten(input: Tensor, start_dim: builtins.int=0, end_dim: builtins.int=-1) -> Tensor: ...

def flip(input: Tensor, dims: Union[Tuple[builtins.int, ...], List[builtins.int], Size]) -> Tensor: ...

def floor(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def fmod(input: Tensor, other: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def fmod(input: Tensor, other: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def frac(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def from_numpy(ndarray) -> Tensor: ...

def full(size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], fill_value: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def full_like(input: Tensor, fill_value: Union[builtins.float, builtins.int]) -> Tensor: ...

@overload
def full_like(input: Tensor, fill_value: Union[builtins.float, builtins.int], *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

def gather(input: Tensor, dim: builtins.int, index: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def ge(input: Tensor, other: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def ge(input: Tensor, other: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def gels(input: Tensor, A: Tensor, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

def geqrf(input: Tensor, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

def ger(input: Tensor, vec2: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def gesv(input: Tensor, A: Tensor, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

def get_default_dtype() -> _dtype: ...

def get_num_threads() -> builtins.int: ...

def get_rng_state(): ...

@overload
def gt(input: Tensor, other: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def gt(input: Tensor, other: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def hamming_window(window_length: builtins.int, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def hamming_window(window_length: builtins.int, periodic: bool, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def hamming_window(window_length: builtins.int, periodic: bool, alpha: builtins.float, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def hamming_window(window_length: builtins.int, periodic: bool, alpha: builtins.float, beta: builtins.float, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def hann_window(window_length: builtins.int, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def hann_window(window_length: builtins.int, periodic: bool, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

def histc(input: Tensor, bins: builtins.int=100, min: Union[builtins.float, builtins.int]=0, max: Union[builtins.float, builtins.int]=0, *, out: Optional[Tensor]=None) -> Tensor: ...

def ifft(input: Tensor, signal_ndim: builtins.int, normalized: bool=False) -> Tensor: ...

def index_select(input: Tensor, dim: builtins.int, index: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def initial_seed(): ...

def inverse(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def irfft(input: Tensor, signal_ndim: builtins.int, normalized: bool=False, onesided: bool=True, signal_sizes: Union[Tuple[builtins.int, ...], List[builtins.int], Size]=()) -> Tensor: ...

def is_storage(obj): ...

def is_tensor(obj): ...

def isfinite(tensor:Tensor) -> Tensor: ...

def isinf(tensor:Tensor) -> Tensor: ...

def isnan(tensor:Tensor) -> Tensor: ...

def kthvalue(input: Tensor, k: builtins.int, dim: builtins.int=-1, keepdim: bool=False, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

@overload
def le(input: Tensor, other: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def le(input: Tensor, other: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def lerp(input: Tensor, end: Tensor, weight: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def linspace(start: Union[builtins.float, builtins.int], end: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def linspace(start: Union[builtins.float, builtins.int], end: Union[builtins.float, builtins.int], steps: builtins.int, *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

def load(f, map_location=None, pickle_module=pickle): ...

def log(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def log10(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def log1p(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def log2(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def logdet(input: Tensor) -> Tensor: ...

@overload
def logspace(start: Union[builtins.float, builtins.int], end: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def logspace(start: Union[builtins.float, builtins.int], end: Union[builtins.float, builtins.int], steps: builtins.int, *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

def logsumexp(input: Tensor, dim: builtins.int, keepdim: bool=False, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def lt(input: Tensor, other: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def lt(input: Tensor, other: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def manual_seed(seed): ...

def masked_select(input: Tensor, mask: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def matmul(input: Tensor, other: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def matrix_power(input: Tensor, n: builtins.int) -> Tensor: ...

@overload
def matrix_rank(input: Tensor, tol: builtins.float, symmetric: bool=False) -> Tensor: ...

@overload
def matrix_rank(input: Tensor, symmetric: bool=False) -> Tensor: ...

@overload
def max(input: Tensor, other: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def max(input: Tensor, *, out: Optional[Tensor]=None) -> Union[builtins.float, builtins.int]: ...

@overload
def max(input: Tensor, dim: builtins.int, keepdim: bool=False, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

@overload
def mean(input: Tensor, *, dtype: _dtype, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def mean(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def mean(input: Tensor, dim: builtins.int, keepdim: bool, *, dtype: _dtype, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def mean(input: Tensor, dim: builtins.int, keepdim: bool=False, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def mean(input: Tensor, dim: builtins.int, *, dtype: _dtype, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def median(input: Tensor, *, out: Optional[Tensor]=None) -> Union[builtins.float, builtins.int]: ...

@overload
def median(input: Tensor, dim: builtins.int, keepdim: bool=False, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

def meshgrid(*tensors, **kwargs): ...

@overload
def min(input: Tensor, other: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def min(input: Tensor, *, out: Optional[Tensor]=None) -> Union[builtins.float, builtins.int]: ...

@overload
def min(input: Tensor, dim: builtins.int, keepdim: bool=False, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

def mm(input: Tensor, mat2: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def mode(input: Tensor, dim: builtins.int=-1, keepdim: bool=False, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

@overload
def mul(input: Tensor, other: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def mul(input: Tensor, other: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None) -> Tensor: ...

def multinomial(input: Tensor, num_samples: builtins.int, replacement: bool=False, *, generator: Generator=None, out: Optional[Tensor]=None) -> Tensor: ...

def mv(input: Tensor, vec: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def mvlgamma(input: Tensor, p: builtins.int) -> Tensor: ...

def narrow(input: Tensor, dim: builtins.int, start: builtins.int, length: builtins.int) -> Tensor: ...

@overload
def ne(input: Tensor, other: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def ne(input: Tensor, other: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def neg(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def nonzero(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def norm(input, p='fro', dim=None, keepdim=False, out=None): ...

@overload
def normal(mean: Tensor, std: builtins.float=1, *, generator: Generator=None, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def normal(mean: builtins.float, std: Tensor, *, generator: Generator=None, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def normal(mean: Tensor, std: Tensor, *, generator: Generator=None, out: Optional[Tensor]=None) -> Tensor: ...

def numel(input: Tensor) -> builtins.int: ...

@overload
def ones(size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def ones(*size: builtins.int, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def ones_like(input: Tensor) -> Tensor: ...

@overload
def ones_like(input: Tensor, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

def orgqr(input: Tensor, input2: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def ormqr(input: Tensor, input2: Tensor, input3: Tensor, left: bool=True, transpose: bool=False, *, out: Optional[Tensor]=None) -> Tensor: ...

def pdist(input: Tensor, p: builtins.float=2) -> Tensor: ...

def pinverse(input: Tensor, rcond: builtins.float=1e-15) -> Tensor: ...

def pixel_shuffle(input: Tensor, upscale_factor: builtins.int) -> Tensor: ...

def potrf(input: Tensor, upper: bool=True, *, out: Optional[Tensor]=None) -> Tensor: ...

def potri(input: Tensor, upper: bool=True, *, out: Optional[Tensor]=None) -> Tensor: ...

def potrs(input: Tensor, input2: Tensor, upper: bool=True, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def pow(input: Tensor, exponent: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def pow(input: Union[builtins.float, builtins.int], exponent: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def pow(input: Tensor, exponent: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def prod(input: Tensor, *, dtype: _dtype, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def prod(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def prod(input: Tensor, dim: builtins.int, keepdim: bool, *, dtype: _dtype, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def prod(input: Tensor, dim: builtins.int, keepdim: bool=False, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def prod(input: Tensor, dim: builtins.int, *, dtype: _dtype, out: Optional[Tensor]=None) -> Tensor: ...

def pstrf(input: Tensor, upper: bool=True, tol: Union[builtins.float, builtins.int]=-1, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

def qr(input: Tensor, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

@overload
def rand(size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def rand(*size: builtins.int, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def rand(size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], *, generator: Generator, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def rand(*size: builtins.int, generator: Generator, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def rand_like(input: Tensor) -> Tensor: ...

@overload
def rand_like(input: Tensor, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def randint(high: builtins.int, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def randint(high: builtins.int, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], *, generator: Generator, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def randint(low: builtins.int, high: builtins.int, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def randint(low: builtins.int, high: builtins.int, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], *, generator: Generator, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def randint_like(input: Tensor, high: builtins.int) -> Tensor: ...

@overload
def randint_like(input: Tensor, low: builtins.int, high: builtins.int) -> Tensor: ...

@overload
def randint_like(input: Tensor, high: builtins.int, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def randint_like(input: Tensor, low: builtins.int, high: builtins.int, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def randn(size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def randn(*size: builtins.int, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def randn(size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], *, generator: Generator, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def randn(*size: builtins.int, generator: Generator, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def randn_like(input: Tensor) -> Tensor: ...

@overload
def randn_like(input: Tensor, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def randperm(n: builtins.int, *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def randperm(n: builtins.int, *, generator: Generator, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def range(start: Union[builtins.float, builtins.int], end: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def range(start: Union[builtins.float, builtins.int], end: Union[builtins.float, builtins.int], step: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

def reciprocal(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def relu_(input: Tensor) -> Tensor: ...

@overload
def remainder(input: Tensor, other: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def remainder(input: Tensor, other: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def renorm(input: Tensor, p: Union[builtins.float, builtins.int], dim: builtins.int, maxnorm: Union[builtins.float, builtins.int], *, out: Optional[Tensor]=None) -> Tensor: ...

def reshape(input: Tensor, shape: Union[Tuple[builtins.int, ...], List[builtins.int], Size]) -> Tensor: ...

def rfft(input: Tensor, signal_ndim: builtins.int, normalized: bool=False, onesided: bool=True) -> Tensor: ...

def rot90(input: Tensor, k: builtins.int=1, dims: Union[Tuple[builtins.int, ...], List[builtins.int], Size]=(0,1)) -> Tensor: ...

def round(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def rrelu_(input: Tensor, lower: Union[builtins.float, builtins.int]=0.125, upper: Union[builtins.float, builtins.int]=0.3333333333333333, training: bool=False, generator: Generator=None) -> Tensor: ...

def rsqrt(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def save(obj, f, pickle_module=pickle, pickle_protocol=2): ...

def selu_(input: Tensor) -> Tensor: ...

def set_default_dtype(d): ...

def set_default_tensor_type(t): ...

def set_flush_denormal(mode: bool) -> bool: ...

def set_num_threads(num: builtins.int) -> None: ...

def set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, profile=None): ...

def set_rng_state(new_state): ...

def sigmoid(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def sign(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def sin(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def sinh(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def slogdet(input: Tensor) -> Tuple[Tensor, Tensor]: ...

def sort(input: Tensor, dim: builtins.int=-1, descending: bool=False, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

@overload
def sparse_coo_tensor(indices: Tensor, values: Tensor) -> Tensor: ...

@overload
def sparse_coo_tensor(indices: Tensor, values: Tensor, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size]) -> Tensor: ...

@overload
def sparse_coo_tensor(size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def sparse_coo_tensor(*size: builtins.int, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def sparse_coo_tensor(indices: Tensor, values: Tensor, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def sparse_coo_tensor(indices: Tensor, values: Tensor, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

def split(tensor:Tensor, split_size_or_sections:Union[List[builtins.int], builtins.int], dim:builtins.int=0) -> List[Tensor]: ...

def sqrt(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def squeeze(input: Tensor) -> Tensor: ...

@overload
def squeeze(input: Tensor, dim: builtins.int) -> Tensor: ...

@overload
def sspaddmm(beta: Union[builtins.float, builtins.int], input: Tensor, alpha: Union[builtins.float, builtins.int], mat1: Tensor, mat2: Tensor) -> Tensor: ...

@overload
def sspaddmm(beta: Union[builtins.float, builtins.int], input: Tensor, mat1: Tensor, mat2: Tensor) -> Tensor: ...

def stack(tensors: Union[Tuple[Tensor, ...],List[Tensor]], dim: builtins.int=0, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def std(input: Tensor, unbiased: bool=True, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def std(input: Tensor, dim: builtins.int, unbiased: bool=True, keepdim: bool=False, *, out: Optional[Tensor]=None) -> Tensor: ...

def stft(input, n_fft, hop_length=None, win_length=None, window=None, center=True, pad_mode='reflect', normalized=False, onesided=True): ...

@overload
def sub(input: Tensor, alpha: Union[builtins.float, builtins.int], other: Tensor) -> Tensor: ...

@overload
def sub(input: Tensor, alpha: Union[builtins.float, builtins.int], other: Tensor, *, out: Tensor) -> Tensor: ...

@overload
def sum(input: Tensor, *, dtype: _dtype, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def sum(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def sum(input: Tensor, dim: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size], keepdim: bool, *, dtype: _dtype, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def sum(input: Tensor, dim: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size], keepdim: bool=False, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def sum(input: Tensor, dim: Union[builtins.int, Tuple[builtins.int, ...], List[builtins.int], Size], *, dtype: _dtype, out: Optional[Tensor]=None) -> Tensor: ...

def svd(input: Tensor, some: bool=True, compute_uv: bool=True, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor, Tensor]: ...

def symeig(input: Tensor, eigenvectors: bool=False, upper: bool=True, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

def t(input: Tensor) -> Tensor: ...

def take(input: Tensor, index: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def tan(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def tanh(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def tensor(data: Any, dtype: Optional[_dtype]=None, device: Union[device, str, None]=None, requires_grad: bool=False) -> Tensor: ...

@overload
def tensor(storage: Storage, storageOffset: builtins.int, size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], stride: Union[Tuple[builtins.int, ...], List[builtins.int], Size]=()) -> Tensor: ...

@overload
def tensor(size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], stride: Union[Tuple[builtins.int, ...], List[builtins.int], Size]) -> Tensor: ...

def tensordot(a:Tensor, b:Tensor, dims=2) -> Tensor: ...

def topk(input: Tensor, k: builtins.int, dim: builtins.int=-1, largest: bool=True, sorted: bool=True, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

def trace(input: Tensor) -> Union[builtins.float, builtins.int]: ...

def transpose(input: Tensor, dim0: builtins.int, dim1: builtins.int) -> Tensor: ...

def tril(input: Tensor, diagonal: builtins.int=0, *, out: Optional[Tensor]=None) -> Tensor: ...

def triu(input: Tensor, diagonal: builtins.int=0, *, out: Optional[Tensor]=None) -> Tensor: ...

def trtrs(input: Tensor, A: Tensor, upper: bool=True, transpose: bool=False, unitriangular: bool=False, *, out: Optional[Tensor]=None) -> Tuple[Tensor, Tensor]: ...

def trunc(input: Tensor, *, out: Optional[Tensor]=None) -> Tensor: ...

def unbind(input: Tensor, dim: builtins.int=0) -> Union[Tuple[Tensor, ...],List[Tensor]]: ...

def unique(input, sorted=False, return_inverse=False, dim=None): ...

def unsqueeze(input: Tensor, dim: builtins.int) -> Tensor: ...

@overload
def var(input: Tensor, unbiased: bool=True, *, out: Optional[Tensor]=None) -> Tensor: ...

@overload
def var(input: Tensor, dim: builtins.int, unbiased: bool=True, keepdim: bool=False, *, out: Optional[Tensor]=None) -> Tensor: ...

def where(condition: Tensor, input: Tensor, other: Tensor) -> Tensor: ...

@overload
def zeros(size: Union[Tuple[builtins.int, ...], List[builtins.int], Size], *, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def zeros(*size: builtins.int, out: Optional[Tensor]=None, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...

@overload
def zeros_like(input: Tensor) -> Tensor: ...

@overload
def zeros_like(input: Tensor, *, dtype: _dtype=None, layout: layout=strided, device: Union[device, str, None]=None, requires_grad:bool=False) -> Tensor: ...



class DoubleStorage(Storage): ...

class FloatStorage(Storage): ...

class LongStorage(Storage): ...

class IntStorage(Storage): ...

class ShortStorage(Storage): ...

class CharStorage(Storage): ...

class ByteStorage(Storage): ...

class DoubleTensor(Tensor): ...

class FloatTensor(Tensor): ...

class LongTensor(Tensor): ...

class IntTensor(Tensor): ...

class ShortTensor(Tensor): ...

class CharTensor(Tensor): ...

class ByteTensor(Tensor): ...

complex128: dtype = ...
complex32: dtype = ...
complex64: dtype = ...
double: dtype = ...
float: dtype = ...
float16: dtype = ...
float32: dtype = ...
float64: dtype = ...
half: dtype = ...
int: dtype = ...
int16: dtype = ...
int32: dtype = ...
int64: dtype = ...
int8: dtype = ...
long: dtype = ...
short: dtype = ...
uint8: dtype = ...
